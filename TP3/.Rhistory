# Manage if both highlight are requested
# if(highlight_betweenness & highlight_link_muta_expr){
#   E(graph)$color <- ifelse(betweenness_edges_condition & link_muta_expr_edges_condition, "darkred",
#                            ifelse(betweenness_edges_condition, "black",
#                                   ifelse(link_muta_expr_edges_condition, "red", "gray")))
# }
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
E(graph)$color <- ifelse(edges %in% t, "red", "gray")
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
plot(graph, edge.arrow.size=0.12, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE, miic=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
miic_condition <- edges %in% t
E(graph)$color <- ifelse(miic_condition, "red", "gray")
}
# Manage if highlight betweeness and miic are requested
if(highlight_betweenness & miic){
E(graph)$color <- ifelse(betweenness_edges_condition & miic_condition, "darkred",
ifelse(betweenness_edges_condition, "black",
ifelse(link_muta_expr_edges_condition, "red", "gray")))
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
plot(graph, edge.arrow.size=0.12, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE, miic=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
miic_condition <- edges %in% t
E(graph)$color <- ifelse(miic_condition, "red", "gray")
}
# Manage if highlight betweeness and miic are requested
if(highlight_betweenness & miic){
E(graph)$color <- ifelse(betweenness_edges_condition & miic_condition, "darkred",
ifelse(betweenness_edges_condition, "black",
ifelse(miic_condition, "red", "gray")))
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
plot(graph, edge.arrow.size=0.12, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE, miic=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
miic_condition <- edges %in% t
E(graph)$color <- ifelse(miic_condition, "red", "gray")
}
# Manage if highlight betweeness and miic are requested
if(highlight_betweenness & miic){
E(graph)$color <- ifelse(betweenness_edges_condition & miic_condition, "darkred",
ifelse(betweenness_edges_condition, "black",
ifelse(miic_condition, "red", "gray")))
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
plot(graph, edge.arrow.size=0.13, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE, miic=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
miic_condition <- edges %in% t
E(graph)$color <- ifelse(miic_condition, "red", "gray")
}
# Manage if highlight betweeness and miic are requested
if(highlight_betweenness & miic){
E(graph)$color <- ifelse(betweenness_edges_condition & miic_condition, "darkred",
ifelse(betweenness_edges_condition, "black",
ifelse(miic_condition, "red", "gray")))
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
edge_arrow_size = ifelse(miic, 0.14, 0.12)
plot(graph, edge.arrow.size=edge_arrow_size, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE, miic=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
miic_condition <- edges %in% t
E(graph)$color <- ifelse(miic_condition, "red", "gray")
}
# Manage if highlight betweeness and miic are requested
if(highlight_betweenness & miic){
E(graph)$color <- ifelse(betweenness_edges_condition & miic_condition, "darkred",
ifelse(betweenness_edges_condition, "black",
ifelse(miic_condition, "red", "gray")))
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
edge_arrow_size = ifelse(miic, 0.13, 0.12)
plot(graph, edge.arrow.size=edge_arrow_size, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE, miic=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
E(graph)$curved <- FALSE
if(miic){
x <- miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0]
y <- miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0]
t <- apply(cbind(x, y), MARGIN=1, FUN=function(x){ paste(x, collapse="|") } )
edges <- as.matrix(attr(E(graph), "vnames"))
miic_condition <- edges %in% t
E(graph)$color <- ifelse(miic_condition, "red", "gray")
}
# Manage if highlight betweeness and miic are requested
if(highlight_betweenness & miic){
E(graph)$color <- ifelse(betweenness_edges_condition & miic_condition, "darkred",
ifelse(betweenness_edges_condition, "black",
ifelse(miic_condition, "red", "gray")))
}
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
edge_arrow_size = ifelse(miic, 0.12, 0.12)
plot(graph, edge.arrow.size=edge_arrow_size, layout=layout)
}
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
confidenceThreshold <- 0.01
miic.res = miic(inputData = cosmicCancer, categoryOrder = cosmicCancer_stateOrder, latent = TRUE,
confidenceShuffle = confidenceShuffle, confidenceThreshold = confidenceThreshold)
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
confidenceThreshold <- 0.0001
miic.res = miic(inputData = cosmicCancer, categoryOrder = cosmicCancer_stateOrder, latent = TRUE,
confidenceShuffle = confidenceShuffle, confidenceThreshold = confidenceThreshold)
plot_graph(miic.res, bnObject_adj=miic.res$adjMatrix, size_offset=7, size_ratio=2,
area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T, miic=TRUE)
# execute MIIC (reconstruct graph)
confidenceShuffle <- 100
confidenceThreshold <- 0.001
miic.res = miic(inputData = cosmicCancer, categoryOrder = cosmicCancer_stateOrder, latent = TRUE,
confidenceShuffle = confidenceShuffle, confidenceThreshold = confidenceThreshold)
names(miic.res$retained.edges.summary)
print_carac(miic.res, miic.res$adjMatrix)
cond <- (miic.res$retained.edges.summary$x == tolower(miic.res$retained.edges.summary$x) & miic.res$retained.edges.summary$y == toupper(miic.res$retained.edges.summary$y)) ||
(miic.res$retained.edges.summary$x == toupper(miic.res$retained.edges.summary$x) & miic.res$retained.edges.summary$y == tolower(miic.res$retained.edges.summary$y))
miic.res$retained.edges.summary[cond]$x
miic.res$retained.edges.summary[cond]
cond <- (miic.res$retained.edges.summary$x == tolower(miic.res$retained.edges.summary$x) & miic.res$retained.edges.summary$y == toupper(miic.res$retained.edges.summary$y)) |
(miic.res$retained.edges.summary$x == toupper(miic.res$retained.edges.summary$x) & miic.res$retained.edges.summary$y == tolower(miic.res$retained.edges.summary$y))
cond
miic.res$retained.edges.summary[cond]
miic.res$retained.edges.summary[cond,]
res <- miic.res$retained.edges.summary[cond,]
res$x
res$y
res$log_confidence
res$partial_correlation
cbind(res$x[res$partial_correlation < 0], res$y[res$partial_correlation < 0])
cbind(miic.res$retained.edges.summary$x[miic.res$retained.edges.summary$partial_correlation < 0], miic.res$retained.edges.summary$y[miic.res$retained.edges.summary$partial_correlation < 0])
cbind(res$x, res$y, res$log_confidence, res$partial_correlation)
miic.res$retained.edges.summary[miic.res$retained.edges.summary$x == "Ploidy",]$partial_correlation
miic.res$retained.edges.summary$x
sort(miic.res$retained.edges.summary$x)
sort(miic.res$retained.edges.summary$y)
# Get partial correlation and log confidence of dege involving "Ploidy"
cond <- miic.res$retained.edges.summary$x == "Ploidy" | miic.res$retained.edges.summary$y == "Ploidy"
res <- miic.res$retained.edges.summary[cond,]
cbind(res$x, res$y, res$log_confidence, res$partial_correlation)
# execute MIIC (reconstruct graph)
confidenceShuffle <- 1000
confidenceThreshold <- 0.001
miic.res = miic(inputData = cosmicCancer, categoryOrder = cosmicCancer_stateOrder, latent = TRUE,
confidenceShuffle = confidenceShuffle, confidenceThreshold = confidenceThreshold)
# Get partial correlation and log confidence of dege involving "Ploidy"
cond <- miic.res$retained.edges.summary$x == "Ploidy" | miic.res$retained.edges.summary$y == "Ploidy"
res <- miic.res$retained.edges.summary[cond,]
cbind(res$x, res$y, res$log_confidence, res$partial_correlation)
# execute MIIC (reconstruct graph)
confidenceShuffle <- 10
confidenceThreshold <- 0.001
miic.res = miic(inputData = cosmicCancer, categoryOrder = cosmicCancer_stateOrder, latent = TRUE,
confidenceShuffle = confidenceShuffle, confidenceThreshold = confidenceThreshold)
# Get partial correlation and log confidence of dege involving "Ploidy"
cond <- miic.res$retained.edges.summary$x == "Ploidy" | miic.res$retained.edges.summary$y == "Ploidy"
res <- miic.res$retained.edges.summary[cond,]
cbind(res$x, res$y, res$log_confidence, res$partial_correlation)
