t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))
)
t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))})
)
dim(t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))})))
typeof(t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))})))
t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))}))
########################################################
# Network reconstruction with the PC approach
########################################################
# ------- 2
pc_data <- data.matrix(data) - 1
pc_data <- t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))}))
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
# ------- 3
pc_data <- data.matrix(data_cleaned) - 1
pc_data <- t(apply(pc_data, MARGIN=1, FUN=function(x){as.integer(as.factor(x))}))
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
pc_data
min(pc_data)
# ------- 3
pc_data <- data.matrix(data_cleaned) - 1
pc_data <- t(apply(pc_data, MARGIN=1, FUN=function(x){ as.integer(as.factor(x))-1 } ))
min(pc_data)
pc_data
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
pc_data[,1]
temp <- t(apply(pc_data, MARGIN=1, FUN=function(x){ as.integer(as.factor(x))-1 } ))
temp[,1]
temp <- t(apply(pc_data, MARGIN=1, FUN=function(x){ as.factor(as.integer(x))-1 } ))
temp <- t(apply(pc_data, MARGIN=1, FUN=function(x){ as.factor(as.integer(x))-1 } ))
warnings()
temp
temp <- t(apply(pc_data, MARGIN=1, FUN=function(x){ as.factor(as.integer(x)-1) } ))
temp[,1]
typeof(temp)
data_cleaned
# ------- 3
pc_data <- data.matrix(data_cleaned) - 1
pc_data
temp <- t(apply(pc_data, MARGIN=1, FUN=as.factor ))
temp
temp[,1]
########################################################
# Network reconstruction with the PC approach
########################################################
# ------- 2
pc_data <- data.matrix(data) - 1
pc_data
# ------- 3
pc_data <- data.matrix(data_cleaned) - 1
pc_data
(pc_data)
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=as.factor)
pc_data
data_cleaned
data_cleaned - 1
data_cleaned
as.integer(data_cleaned[,1])
as.integer(data_cleaned[,2])
as.integer(data_cleaned[,178])
as.integer(data_cleaned[,167])
as.integer(data_cleaned[,162])
data_cleaned[,1]
dim(data_cleaned)
unique(data_cleaned[,1])
as.factor(as.integer(data_cleaned[,162]) - 1)
pc_data <- t(apply(data_cleaned, MARGIN=1, FUN=function(x){ as.factor(as.integer(x))-1 } ))
pc_data
pc_data <- t(apply(data_cleaned, MARGIN=2, FUN=function(x){ as.factor(as.integer(x))-1 } ))
pc_data
dim(pc_data)
pc_data <- t(apply(data_cleaned, MARGIN=2, FUN=function(x){ as.factor(as.integer(x)-1) } ))
as.factor(as.integer(data_cleaned[,162]) - 1)
apply(data_cleaned, MARGIN=2, FUN=function(x){ as.factor(as.integer(x) - 1) } )
lapply(data_cleaned, MARGIN=2, FUN=function(x){ as.factor(as.integer(x) - 1) } )
sapply(data_cleaned, MARGIN=2, FUN=function(x){ as.factor(as.integer(x) - 1) } )
?apply
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
pc_data
pc_data[,1]
########################################################
# Network reconstruction with the PC approach
########################################################
# ------- 2
pc_data <- data
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
# ------- 3
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
pc_data
apply(pc_data, MARGIN=2, FUN=min)
sum(apply(pc_data, MARGIN=2, FUN=min) != 0)
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
nlev
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
# ------- 3
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data), verbose=T)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(bnlearn)
library(igraph)
library(pcalg)
data(insurance)
compute_statistics <- function(real_graph, graph_2, do_print=TRUE){
tp <- sum(attr(E(graph_2), "vnames") %in% attr(E(real_graph), "vnames"))
fp <- sum(attr(E(graph_2), "vnames") %in% attr(E(real_graph), "vnames") == FALSE)
fn <- sum(attr(E(real_graph), "vnames") %in% attr(E(graph_2), "vnames") == FALSE)
#compute_statistics <- function(adj_1, adj_2, do_print=TRUE){
#tp <- sum(adj_1 == adj_2 & adj_1 != 0 & adj_2 != 0)
#fp <- sum(adj_1 != adj_2 & adj_2 != 0)
#fn <- sum(adj_1 != adj_2 & adj_1 != 0)
precision <- tp / (tp + fp)
recall <- tp / (tp + fn)
fscore <- 2 * (precision * recall) / (precision + recall)
if(do_print){
cat("TP        = ", tp, "\n", sep=" ")
cat("FP        = ", fp, "\n", sep=" ")
cat("FN        = ", fn, "\n", sep=" ")
cat("Precision = ", precision, "\n", sep=" ")
cat("Recall    = ", recall, "\n", sep=" ")
cat("Fscore    = ", fscore, "\n", sep=" ")
}
return(c("tp"=tp, "fp"=fp, "fn"=fn, "precision"=precision, "recall"=recall,
"fscore"=fscore))
}
plot_graph <- function(adj, real_graph=NULL, offset_size=15, layout=layout_with_dh){
graph <- graph_from_adjacency_matrix(adj)
deg <- degree(graph, mode = "all")
V(graph)$size <- deg + offset_size
if(! is.null(real_graph)){
E(graph)$color <- ifelse(attr(E(graph), "vnames") %in% attr(E(real_graph), "vnames"), "grey","red")
E(graph)$width <- ifelse(attr(E(graph), "vnames") %in% attr(E(real_graph), "vnames"), 1, 2)
}
plot(graph, edge.arrow.size=0.4, layout=layout)
}
# Plot with graphviz
plot_graph2 <- function(bnObject, real_bnObject=NULL, fontsize=3, layoutFun="dot"){
g <- Rgraphviz::layoutGraph(bnlearn::as.graphNEL(bnObject), layoutType=layoutFun)
graph::nodeRenderInfo(g) <- list(fontsize=fontsize, shape="circle")
if(! is.null(real_bnObject)){
# Get skeleton
bnObject2 <- bnlearn::skeleton(bnObject)
g2 <- Rgraphviz::layoutGraph(bnlearn::as.graphNEL(bnObject2))
g2_edge <- graph::edgeRenderInfo(g2)
real_bnObject <- bnlearn::skeleton(real_bnObject)
real_g <- Rgraphviz::layoutGraph(bnlearn::as.graphNEL(real_bnObject))
real_g_edge <- graph::edgeRenderInfo(real_g)
new_col <- graph::edgeRenderInfo(g)$col
g_names <- names(new_col)
fp_edge <- bnlearn::compare(real_bnObject, bnObject2, arcs=T)$fp
fp_edge_names <- apply(fp_edge, MARGIN=1, FUN=function(x){ paste(x[1],x[2],sep="~") })
print(g_names[g_names %in% fp_edge_names])
new_col[g_names %in% fp_edge_names] <- "red"
graph::edgeRenderInfo(g) <- list(col=new_col)
# real_g <- Rgraphviz::layoutGraph(bnlearn::as.graphNEL(real_bnObject))
# real_g_names <- names(graph::edgeRenderInfo(real_g)$col)
# new_col <- graph::edgeRenderInfo(g)$col
# g_names <- names(new_col)
# indexes <- ! g_names %in% real_g_names
# new_col[indexes] <- "red"
# graph::edgeRenderInfo(g) <- list(col=new_col)
}
Rgraphviz::renderGraph(g)
}
#######
# 1
#######
# b
modelstring = paste0("[Age][Mileage][SocioEcon|Age][GoodStudent|Age:SocioEcon]",
"[RiskAversion|Age:SocioEcon][OtherCar|SocioEcon][VehicleYear|SocioEcon:RiskAversion]",
"[MakeModel|SocioEcon:RiskAversion][SeniorTrain|Age:RiskAversion]",
"[HomeBase|SocioEcon:RiskAversion][AntiTheft|SocioEcon:RiskAversion]",
"[RuggedAuto|VehicleYear:MakeModel][Antilock|VehicleYear:MakeModel]",
"[DrivingSkill|Age:SeniorTrain][CarValue|VehicleYear:MakeModel:Mileage]",
"[Airbag|VehicleYear:MakeModel][DrivQuality|RiskAversion:DrivingSkill]",
"[Theft|CarValue:HomeBase:AntiTheft][Cushioning|RuggedAuto:Airbag]",
"[DrivHist|RiskAversion:DrivingSkill][Accident|DrivQuality:Mileage:Antilock]",
"[ThisCarDam|RuggedAuto:Accident][OtherCarCost|RuggedAuto:Accident]",
"[MedCost|Age:Accident:Cushioning][ILiCost|Accident]",
"[ThisCarCost|ThisCarDam:Theft:CarValue][PropCost|ThisCarCost:OtherCarCost]")
dag = model2network(modelstring)
# c
typeof(dag)
dag
# d
real_adj <- amat(dag)
#real_adj <- amat(cpdag(dag))
# e
real_graph <- graph_from_adjacency_matrix(real_adj)
plot_graph(real_adj)
plot_graph2(dag)
#######
# 2
#######
# b
hc_res <- hc(insurance)
# c
hc_adj <- amat(hc_res)
hc_graph <- graph_from_adjacency_matrix(hc_adj)
# d
plot_graph(hc_adj)
# e
hc_graph <- graph_from_adjacency_matrix(hc_adj)
hc_stats <- compute_statistics(real_graph, hc_graph)
hc_stats <- compute_statistics(graph_from_adjacency_matrix(amat(bnlearn::skeleton(dag))), graph_from_adjacency_matrix(amat(bnlearn::skeleton(hc_res))))
hc_stats <- compute_statistics(graph_from_adjacency_matrix(amat(cpdag(dag))), graph_from_adjacency_matrix(amat(cpdag(hc_res))))
bnlearn::compare(dag, hc_res)
# f
plot_graph(hc_adj, real_graph, offset_size=11)
plot_graph2(hc_res, fontsize=60)
plot_graph2(hc_res, dag, fontsize=60)
temp <- graphviz.compare(dag, hc_res)
#######
# 3
#######
# a
data <- data.matrix(insurance) - 1
nlev=apply(data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(data))
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
library(bnlearn)
library(igraph)
library(pcalg)
library(miic)
library(qgraph)
data("cosmicCancer")
data <- cosmicCancer
dim(data)
# ------- Remove samples with NA values
data_cleaned <- data[complete.cases(data), ]
dim(data_cleaned)
# We have removed 8 samples with NA values
colSums(is.na(data))[colSums(is.na(data)) != 0]
# ------- Remove variables with constant value
data_cleaned <- data_cleaned[, apply(data_cleaned, MARGIN=2, FUN=function(x){length(unique(x))}) != 1]
dim(data_cleaned)
# ------- As factor
col <- names(data_cleaned)
data_cleaned[col] <- lapply(data_cleaned[col], FUN=as.factor)
as_factor_matrix <- function(matrix){
col <- names(matrix)
matrix[col] <- lapply(matrix[col], FUN=as.factor)
return(matrix)
}
#####################
# Plot with igraph
#####################
plot_graph <- function(bnObject, bnObject_adj=NULL, area_ratio=8, size_offset=7, size_ratio=2, highlight_betweenness=FALSE,
highlight_link_muta_expr=FALSE){
if(is.null(bnObject_adj))
graph <- graph_from_adjacency_matrix(amat(bnObject), mode="directed")
else
graph <- graph_from_adjacency_matrix(bnObject_adj, mode="directed")
# Customize colors
V(graph)$color <- ifelse(names(V(graph)) == tolower(names(V(graph))), "orange",
ifelse(names(V(graph)) == toupper(names(V(graph))), "cyan",
"green"))
# Highlist top nodes and arcs according to betweenness centrality
if(highlight_betweenness){
# --- nodes
nodes_condition <- V(graph) %in% V(graph)[rev(order(betweenness(graph)))[1:10]]
# node shape
V(graph)$shape <- ifelse(nodes_condition, "square", "circle")
# node contour color
V(graph)$frame.color <- ifelse(nodes_condition, "black", "gray")
# --- edges
betweenness_edges_condition <- E(graph) %in% E(graph)[rev(order(edge_betweenness(graph)))[1:10]]
# edge color
E(graph)$color <- ifelse(betweenness_edges_condition, "black", "gray")
# edge width
E(graph)$width <- ifelse(betweenness_edges_condition, 4, 3)
}
# Highlight link between mutated and expressed genes
if(highlight_link_muta_expr){
edges <- t( apply(as.matrix(attr(E(graph), "vnames")), MARGIN=1, FUN=function(x){ unlist(strsplit(x, "[|]")) }) )
link_muta_expr_edges_condition <- (edges[,1]==toupper(edges[,1]) & edges[,2]==tolower(edges)[,2]) |
(edges[,2]==toupper(edges[,2]) & edges[,1]==tolower(edges)[,1])
# edge color
#E(graph)$color <- ifelse(link_muta_expr_edges_condition, "red", "gray")
# node symbol font
nodes <- unique(c(edges[link_muta_expr_edges_condition]))
nodes <- nodes[nodes == tolower(nodes)]
V(graph)$label.font <- ifelse(V(graph) %in% V(graph)[nodes], 2, 1)
}
# Manage if both highlight are requested
# if(highlight_betweenness & highlight_link_muta_expr){
#   E(graph)$color <- ifelse(betweenness_edges_condition & link_muta_expr_edges_condition, "darkred",
#                            ifelse(betweenness_edges_condition, "black",
#                                   ifelse(link_muta_expr_edges_condition, "red", "gray")))
# }
# Customize size
deg <- degree(graph, mode = "all")
V(graph)$size <- log(deg)*size_ratio + size_offset
# Remove node with 0 degree
graph <- delete.vertices(graph, which(deg==0))
# Create layout
e <- get.edgelist(graph, names=F)
layout <- qgraph.layout.fruchtermanreingold(e, vcount=vcount(graph),
area=area_ratio*(vcount(graph)^2),
repulse.rad=(vcount(graph)^3.1))
# Plot
plot(graph, edge.arrow.size=0.12, layout=layout)
}
#####################
# Plot with graphviz
#####################
plot_graph2 <- function(bnObject, fontsize=0, layoutFun="dot"){
g <- Rgraphviz::layoutGraph(bnlearn::as.graphNEL(bnObject), layoutType=layoutFun)
graph::nodeRenderInfo(g) <- list(fontsize=fontsize, shape="circle")
# Customize colors
node_names <- names(graph::nodeRenderInfo(g)$col)
graph::nodeRenderInfo(g)$col[node_names == tolower(node_names)] <- "red"
graph::nodeRenderInfo(g)$col[node_names == toupper(node_names)] <- "blue"
# Remove node with 0 degree
deg <- degree(graph_from_adjacency_matrix(amat(bnObject)))
graph::nodeRenderInfo(g)$col[deg == 0] <- "white"
graph::nodeRenderInfo(g)$fontsize[deg == 0] <- 1
# Plot
Rgraphviz::renderGraph(g)
}
#####################
# Run
#####################
run_algorithm <- function(data, data_cleaned, algo="hc"){
}
########################################################
# Network reconstruction with the hill-climbing approach
########################################################
# ------- 2
hc_res <- hc(data)
# ------- 3
hc_res <- hc(data_cleaned)
hc_graph <- graph_from_adjacency_matrix(amat(hc_res))
# ------- 4
plot_graph(hc_res, size_offset=7, size_ratio=2, area_ratio=10)
plot_graph2(hc_res)
# ------- 5
# Get hubs
degree <- degree(hc_graph)
sort(degree, decreasing = T)[1:10]
# Get variables related to "Ploidy"
hc_res$nodes$Ploidy$nbr
# Get top 10 nodes and edges with betweenness centrality
# nodes
sort(betweenness(hc_graph), decreasing = T)[1:10]
# edges
E(hc_graph)[rev(order(edge_betweenness(hc_graph)))[1:10]]
plot_graph(hc_res, size_offset=7, size_ratio=2, area_ratio=10, highlight_betweenness=T)
# Get the mutated genes (lower case nodes) that are related to gene expression (upper case nodes)
edges <- hc_res$arcs[ (hc_res$arcs[,1]==toupper(hc_res$arcs[,1]) & hc_res$arcs[,2]==tolower(hc_res$arcs)[,2]) |
(hc_res$arcs[,2]==toupper(hc_res$arcs[,2]) & hc_res$arcs[,1]==tolower(hc_res$arcs)[,1]), ]
nodes <- unique(c(edges))
nodes <- nodes[nodes == tolower(nodes)]
plot_graph(hc_res, size_offset=7, size_ratio=2, area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T)
########################################################
# Network reconstruction with the PC approach
########################################################
# ------- 2
pc_data <- data
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
# ------- 3
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
data_cleaned
data_cleaned[,1]
pc_data
pc_data[,1]
pc_data[,2]
pc_data[,5]
pc_data[,147]
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
typeof(pc_data)
pc_data
as.matrix(pc_data)
typeof(as.matrix(pc_data)
)
as.matrix(pc_data)[,1]
unlist(pc_data)
dim(unlist(pc_data))
# ------- 3
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ unlist(as.factor(as.integer(x)-1)) } )
pc_data
typeof(pc_data)
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
typeof(data_cleaned)
typeof(data)
any(pc_dat == 0)
any(pc_data == 0)
!any(pc_data == 0)
?pc
# ------- 3
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.factor(as.integer(x)-1) } )
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
is.data.frame(pc_data)
data.matrix(pc_data)
pc_data
# ------- 3
pc_data <- data_cleaned
pc_data
as.integer(pc_data)
apply(pc_data, MARGIN=2, FUN=as.integer)
pc_data
# ------- 3
pc_data <- data_cleaned
col <- names(pc_data)
pc_data[col] <- lapply(pc_data[col], FUN=function(x){ as.integer(x)-1 } )
pc_data
nlev=apply(pc_data, MARGIN=2, FUN=function(x){ length(attr(as.factor(x), "levels")) })
pc_res <- pc(suffStat=list(dm = pc_data, nlev=nlev, adaptDF = FALSE), indepTest=disCItest, alpha=0.05, labels=colnames(pc_data))
pc_adj <- as(pc_res, "amat")
pc_graph <- graph_from_adjacency_matrix(pc_adj)
# ------- 4
plot_graph(pc_res, size_offset=7, size_ratio=2, area_ratio=10)
# ------- 4
plot_graph(as.bn(pc_res), size_offset=7, size_ratio=2, area_ratio=10)
plot_graph(as.bn(pc_res), size_offset=7, size_ratio=2, area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T)
# ------- 5
# Get hubs
degree <- degree(pc_graph)
sort(degree, decreasing = T)[1:10]
# Get variables related to "Ploidy"
pc_res$nodes$Ploidy$nbr
# Get variables related to "Ploidy"
as.bn(pc_res)$nodes$Ploidy$nbr
# Get top 10 nodes and edges with betweenness centrality
# nodes
sort(betweenness(pc_graph), decreasing = T)[1:10]
# GMPS DIAPH3  CCNE2   ECT2   PRC1  CENPA   RFC4  CCNE1   tp53  AURKB
# 22.0   13.5   12.5   12.5   11.0   10.0   10.0    9.0    8.0    7.0
# edges
E(pc_graph)[rev(order(edge_betweenness(pc_graph)))[1:10]]
# Get the mutated genes (lower case nodes) that are related to gene expression (upper case nodes)
edges <- pc_res$arcs[ (pc_res$arcs[,1]==toupper(pc_res$arcs[,1]) & pc_res$arcs[,2]==tolower(pc_res$arcs)[,2]) |
(pc_res$arcs[,2]==toupper(pc_res$arcs[,2]) & pc_res$arcs[,1]==tolower(pc_res$arcs)[,1]), ]
nodes <- unique(c(edges))
nodes[nodes == tolower(nodes)]
pc_res
?pc
pc_res$graph
attributes(pc_res)
attributes(hc_res)
pc_res$pMax
attr(pc_res, "pMax")
dim(attr(pc_res, "pMax"))
dim(pc_data)
dim(data_cleaned)
typeof(attr(pc_res, "pMax"))
attr(pc_res, "pMax")[1:10]
names(attr(pc_res, "pMax"))
names(list(attr(pc_res, "pMax")))
names(list(attr(pc_res, "pMax")))pc_res$names
pc_res$names
attr(pc_res, "named")
attr(pc_res, "names")
attr(pc_res, "nike")
# Get the mutated genes (lower case nodes) that are related to gene expression (upper case nodes)
edges <- as.bn(pc_res)$arcs[ (as.bn(pc_res)$arcs[,1]==toupper(as.bn(pc_res)$arcs[,1]) & as.bn(pc_res)$arcs[,2]==tolower(as.bn(pc_res)$arcs)[,2]) |
(as.bn(pc_res)$arcs[,2]==toupper(as.bn(pc_res)$arcs[,2]) & as.bn(pc_res)$arcs[,1]==tolower(as.bn(pc_res)$arcs)[,1]), ]
nodes <- unique(c(edges))
nodes[nodes == tolower(nodes)]
plot_graph(as.bn(pc_res), size_offset=7, size_ratio=2, area_ratio=10, highlight_betweenness=T, highlight_link_muta_expr=T)
?pc
# ------- 5
# Get hubs
degree <- degree(hc_graph)
sort(degree, decreasing = T)[1:10]
# Get variables related to "Ploidy"
hc_res$nodes$Ploidy$nbr
?betweenness
?miic
data(cosmicCancer)
data(cosmicCancer_stateOrder)
# execute MIIC (reconstruct graph)
miic.res = miic(inputData = cosmicCancer, categoryOrder = cosmicCancer_stateOrder, latent = TRUE,
confidenceShuffle = 100, confidenceThreshold = 0.001)
# plot graph
miic.plot(miic.res, igraphLayout=igraph::layout_on_grid)
# plot graph
miic.plot(miic.res, igraphLayout=layout_with_drl)
miic.res
as.bn(miic.res)
?miic
